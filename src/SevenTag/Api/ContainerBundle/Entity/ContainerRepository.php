<?php
/**
 * Copyright (C) 2015 Digimedia Sp. z o.o. d/b/a Clearcode
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

namespace SevenTag\Api\ContainerBundle\Entity;

use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\ORM\Query;
use Doctrine\ORM\QueryBuilder;
use FOS\UserBundle\Model\UserInterface;
use SevenTag\Api\AppBundle\Search\Criteria;
use SevenTag\Api\AppBundle\Utils\Doctrine\LikeSanitizer;
use SevenTag\Api\AppBundle\Versionable\VersionableRepositoryInterface;
use SevenTag\Component\Model\Repository\EntityRepository as BaseEntityRepository;

/**
 * ContainerRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ContainerRepository extends BaseEntityRepository implements VersionableRepositoryInterface
{
    /**
     * @param bool $draft
     * @return \Doctrine\ORM\QueryBuilder
     */
    public function getBaseQuery($draft = true)
    {
        $queryBuilder = $this->createQueryBuilder('c')
            ->join('c.version', 'v')
            ->andWhere('v.draft = :draft')
            ->andWhere('v.published = :published')
            ->setParameter('draft', $draft)
            ->setParameter('published', !$draft);

        return $queryBuilder;
    }

    /**
     * @return \Doctrine\ORM\QueryBuilder
     */
    public function getWithConditionsQueryBuilder()
    {
        return $this->createQueryBuilder('c')
            ->select('c', 'tg', 'tr', 'cd')
            ->leftJoin('c.tags', 'tg')
            ->leftJoin('tg.triggers', 'tr')
            ->leftJoin('tr.conditions', 'cd');
    }

    /**
     * @param int $id
     * @param int $hydrationMode
     * @return mixed
     */
    public function findOneWithConditions($id, $hydrationMode = Query::HYDRATE_OBJECT)
    {
        return $this->getWithConditionsQueryBuilder()
            ->andWhere('c.id = :id')
            ->setParameter('id', (int)$id)
            ->addOrderBy('tg.priority', 'DESC')
            ->getQuery()
            ->getOneOrNullResult($hydrationMode);
    }


    public function findByCriteria(Criteria $criteria)
    {
        $queryBuilder = $this->getBaseQuery(true)
            ->addOrderBy('c.updatedAt', 'DESC')
            ->addOrderBy('c.id', 'DESC')
            ->setMaxResults($criteria->getLimit())
            ->setFirstResult($criteria->getOffset());

        $this->applyAclSubquery($criteria->getUser(), $queryBuilder);

        if (isset($criteria->name) && strlen($criteria->name) > 0) {
            $queryBuilder->andWhere("c.name LIKE :name ESCAPE '!'");
            $queryBuilder->setParameter('name', LikeSanitizer::sanitize($criteria->name));
        }

        return $queryBuilder
            ->getQuery()
            ->execute();
    }

    /**
     * @param Criteria $criteria
     * @return int
     */
    public function countByCriteria(Criteria $criteria)
    {
        $queryBuilder = $this->getBaseQuery(true)
            ->select('COUNT(c.id)');

        $this->applyAclSubquery($criteria->getUser(), $queryBuilder);

        if (isset($criteria->name) && strlen($criteria->name) > 0) {
            $queryBuilder->andWhere("c.name LIKE :name ESCAPE '!'");
            $queryBuilder->setParameter('name', LikeSanitizer::sanitize($criteria->name));
        }

        return $queryBuilder
            ->getQuery()
            ->getSingleScalarResult();
    }

    /**
     * @param $accessId
     * @return mixed
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function findLastPublishedVersionByAccessId($accessId)
    {
        return $this->getBaseQuery(false)
            ->andWhere('c.accessId = :accessId')
            ->setParameter('accessId', $accessId)
            ->orderBy('c.id', 'DESC')
            ->setMaxResults(1)
            ->getQuery()
            ->getOneOrNullResult();
    }

    /**
     * @param array $accessIds
     * @return mixed
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function findLastPublishedVersionByAccessIds(array $accessIds)
    {
        return $this->getBaseQuery(false)
            ->andWhere('c.accessId IN (:accessIds)')
            ->setParameter('accessIds', $accessIds)
            ->orderBy('c.id', 'DESC')
            ->getQuery()
            ->execute();
    }

    /**
     * {@inheritdoc}
     */
    public function findByAccessId($accessId, $draft = true)
    {
        return $this->getBaseQuery($draft)
            ->andWhere('c.accessId = :accessId')
            ->setParameter('accessId', $accessId)
            ->orderBy('c.id', 'DESC')
            ->getQuery()
            ->getOneOrNullResult();
    }

    /**
     * @param $accessId
     * @return mixed
     */
    public function deleteByAccessId($accessId)
    {
        return $this->createQueryBuilder('c')
            ->delete()
            ->where('c.accessId = :accessId')
            ->setParameter('accessId', $accessId)
            ->getQuery()
            ->execute();
    }

    /**
     * @return ArrayCollection|null
     */
    public function findPublished()
    {
        return $this->getBaseQuery(false)
            ->getQuery()
            ->execute();
    }
}
